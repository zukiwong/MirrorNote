import SwiftUI

struct HistoryView: View {
    @EnvironmentObject var viewModel: HistoryViewModel
    @State private var showingSearchDatePicker = false
    @State private var showingSuccessToast = false
    @State private var toastMessage = ""
    @State private var toastIcon = ""
    @State private var selectedDetailItem: EmotionHistoryItem? = nil
    
    var body: some View {
        NavigationView {
            VStack(spacing: 0) {
                // Custom title bar
                titleSection
                
                // Search bar
                searchSection
                
                // History list
                historyListSection
            }
            .navigationBarHidden(true)
            .onTapGesture {
                // ÁÇπÂáªÈ°µÈù¢‰ªªÊÑèÂå∫ÂüüÂèñÊ∂àÈÄâÊã©Êìç‰Ωú
                cancelSelecting()
            }
            .onAppear {
                viewModel.loadHistoryData()
                viewModel.setupNotificationObservers()
            }
            .onReceive(NotificationCenter.default.publisher(for: .navigateToDetailInHistory)) { notification in
                // Â§ÑÁêÜÂØºËà™Âà∞ËØ¶ÊÉÖÈ°µÁöÑÈÄöÁü•
                if let userInfo = notification.userInfo,
                   let historyItem = userInfo["historyItem"] as? EmotionHistoryItem {
                    print("üì± [HistoryView] Êî∂Âà∞ÂØºËà™Âà∞ËØ¶ÊÉÖÈ°µÈÄöÁü•ÔºåÂºÄÂßãÂØºËà™")
                    selectedDetailItem = historyItem
                }
            }
        }
        .successToast(
            isPresented: $showingSuccessToast,
            message: toastMessage,
            icon: toastIcon
        )
    }
    
    // Title area
    private var titleSection: some View {
        VStack(alignment: .leading, spacing: 0) {
            HStack {
                VStack(alignment: .leading, spacing: 4) {
                    Text("History")
                        .font(.system(size: 20, weight: .semibold))
                        .foregroundColor(Color("PrimaryText"))
                        .tracking(3)
                    
                    Text("LONG PRESS CARDS TO MANAGE")
                        .font(.system(size: 11, weight: .light))
                        .foregroundColor(Color("PrimaryText"))
                        .tracking(3)
                }
                
                Spacer()
            }
            .padding(.horizontal, 24)
            .padding(.vertical, 21)
            .background(Color("PrimaryBackground"))
        }
    }
    
    // Search bar area
    private var searchSection: some View {
        VStack(spacing: 0) {
            HStack(spacing: 12) {
                // Logo
                Image(systemName: "circle.fill")
                    .font(.system(size: 20))
                    .foregroundColor(Color("PrimaryText"))
                    .frame(width: 24, height: 24)
                
                // Divider
                Rectangle()
                    .fill(Color("DividerColor"))
                    .frame(width: 1, height: 24)
                
                // Search input field
                TextField("Search keywords...", text: $viewModel.searchText)
                    .font(.system(size: 16))
                    .textFieldStyle(PlainTextFieldStyle())
                    .onTapGesture {
                        viewModel.isSearching = true
                    }
                
                // Clear button
                if !viewModel.searchText.isEmpty || viewModel.selectedDate != nil {
                    Button(action: {
                        viewModel.clearSearch()
                    }) {
                        Image(systemName: "xmark.circle.fill")
                            .font(.system(size: 16))
                            .foregroundColor(.gray)
                    }
                }
                
                // Date selection button
                Button(action: {
                    showingSearchDatePicker.toggle()
                }) {
                    Image(systemName: viewModel.selectedDate != nil ? "calendar.badge.checkmark" : "calendar")
                        .font(.system(size: 16))
                        .foregroundColor(viewModel.selectedDate != nil ? .blue : Color("PrimaryText"))
                }
                .popover(isPresented: $showingSearchDatePicker) {
                    VStack(spacing: 16) {
                        DatePicker(
                            "Select Date",
                            selection: Binding(
                                get: { viewModel.selectedDate ?? Date() },
                                set: { viewModel.selectedDate = $0 }
                            ),
                            displayedComponents: .date
                        )
                        .datePickerStyle(GraphicalDatePickerStyle())
                        
                        // Âø´Êç∑Êó•ÊúüÈÄâÊã©ÊåâÈíÆÁªÑ
                        HStack(spacing: 0) {
                            // Êú¨Âë®ËÆ∞ÂΩïÊåâÈíÆ
                            Button(action: {
                                if let firstDate = viewModel.getFirstRecordDateInCurrentWeek() {
                                    viewModel.selectedDate = firstDate
                                    showingSearchDatePicker = false
                                }
                            }) {
                                Text("Êú¨Âë®ËÆ∞ÂΩï (\(viewModel.getRecordCountInCurrentWeek()))")
                                    .font(.system(size: 14, weight: .medium))
                                    .foregroundColor(viewModel.hasRecordsInCurrentWeek() ? Color("PrimaryText") : Color("SecondaryText"))
                                    .frame(maxWidth: .infinity)
                                    .padding(.vertical, 12)
                                    .background(Color("SecondaryBackground"))
                            }
                            .disabled(!viewModel.hasRecordsInCurrentWeek())
                            
                            // ÂàÜÈöîÁ∫ø
                            Rectangle()
                                .fill(Color("DividerColor"))
                                .frame(width: 1, height: 20)
                            
                            // Êú¨ÊúàËÆ∞ÂΩïÊåâÈíÆ
                            Button(action: {
                                if let firstDate = viewModel.getFirstRecordDateInCurrentMonth() {
                                    viewModel.selectedDate = firstDate
                                    showingSearchDatePicker = false
                                }
                            }) {
                                Text("Êú¨ÊúàËÆ∞ÂΩï (\(viewModel.getRecordCountInCurrentMonth()))")
                                    .font(.system(size: 14, weight: .medium))
                                    .foregroundColor(viewModel.hasRecordsInCurrentMonth() ? Color("PrimaryText") : Color("SecondaryText"))
                                    .frame(maxWidth: .infinity)
                                    .padding(.vertical, 12)
                                    .background(Color("SecondaryBackground"))
                            }
                            .disabled(!viewModel.hasRecordsInCurrentMonth())
                            
                            // ÂàÜÈöîÁ∫ø
                            Rectangle()
                                .fill(Color("DividerColor"))
                                .frame(width: 1, height: 20)
                            
                            // Êú¨Âπ¥ËÆ∞ÂΩïÊåâÈíÆ
                            Button(action: {
                                if let firstDate = viewModel.getFirstRecordDateInCurrentYear() {
                                    viewModel.selectedDate = firstDate
                                    showingSearchDatePicker = false
                                }
                            }) {
                                Text("Êú¨Âπ¥ËÆ∞ÂΩï (\(viewModel.getRecordCountInCurrentYear()))")
                                    .font(.system(size: 14, weight: .medium))
                                    .foregroundColor(viewModel.hasRecordsInCurrentYear() ? Color("PrimaryText") : Color("SecondaryText"))
                                    .frame(maxWidth: .infinity)
                                    .padding(.vertical, 12)
                                    .background(Color("SecondaryBackground"))
                            }
                            .disabled(!viewModel.hasRecordsInCurrentYear())
                        }
                        .background(Color("SecondaryBackground"))
                        .cornerRadius(8)
                        
                        // ÂéüÊúâÁöÑClear DateÂíåOKÊåâÈíÆ
                        HStack {
                            Button("Clear Date") {
                                viewModel.selectedDate = nil
                                showingSearchDatePicker = false
                            }
                            .foregroundColor(.red)
                            
                            Spacer()
                            
                            Button("OK") {
                                showingSearchDatePicker = false
                            }
                            .foregroundColor(.blue)
                        }
                        .padding(.horizontal)
                    }
                    .padding()
                }
                
                // Search icon
                Image("icon-search")
                    .frame(width: 24, height: 24)
            }
            .padding(.horizontal, 10)
            .padding(.vertical, 8)
            .background(
                RoundedRectangle(cornerRadius: 100)
                    .stroke(Color("DividerColor"), lineWidth: 2)
            )
            .padding(.horizontal, 24)
            .padding(.vertical, 15)
            
            // ÂàÜÂâ≤Á∫ø
            Rectangle()
                .fill(Color("DividerColor"))
                .frame(height: 1)
                .padding(.horizontal, 24)
        }
        .background(Color("PrimaryBackground"))
    }
    
    // History list area
    private var historyListSection: some View {
        ScrollView {
            LazyVGrid(columns: [
                GridItem(.flexible(), spacing: 24),
                GridItem(.flexible(), spacing: 24)
            ], spacing: 24) {
                ForEach(viewModel.filteredHistoryItems) { historyItem in
                    EmotionHistoryCard(
                        historyItem: historyItem,
                        onTap: {
                            // ÁÇπÂáªÊ≠£Â∏∏Áä∂ÊÄÅ„ÄÅÂ∞ÅÂ≠òÁä∂ÊÄÅÂíåÂ∑≤ÂØÑÂá∫Áä∂ÊÄÅË∑≥ËΩ¨ËØ¶ÊÉÖÈ°µ
                            if historyItem.actionStatus == .normal || historyItem.actionStatus == .locked || historyItem.actionStatus == .sent {
                                navigateToDetail(historyItem)
                            }
                        },
                        onLongPress: {
                            // ÈïøÊåâËøõÂÖ•ÈÄâÊã©Áä∂ÊÄÅ
                            if historyItem.actionStatus == .normal || historyItem.actionStatus == .sent {
                                withAnimation(.spring(response: 0.6, dampingFraction: 0.8)) {
                                    viewModel.updateActionStatus(for: historyItem.id, to: .selecting)
                                }
                            }
                        },
                        onSelectAction: { action in
                            // ÈÄâÊã©Êìç‰ΩúÂêéËøõÂÖ•Á°ÆËÆ§Áä∂ÊÄÅ
                            withAnimation(.spring(response: 0.5, dampingFraction: 0.8)) {
                                viewModel.updateActionStatus(for: historyItem.id, to: action)
                            }
                        },
                        onConfirmTap: {
                            // ÁÇπÂáªÁ°ÆËÆ§Áä∂ÊÄÅÊâßË°åÊúÄÁªàÊìç‰Ωú
                            handleFinalAction(for: historyItem)
                        },
                        onViewReply: {
                            // Êü•ÁúãÂõû‰ø°ÔºåË∑≥ËΩ¨Âà∞Êî∂‰ª∂ÁÆ±
                            navigateToInbox(emotionEntryId: historyItem.emotionEntry.id.uuidString)
                        }
                    )
                    .background(
                        // Á®ãÂ∫èÂåñÂØºËà™
                        NavigationLink(
                            destination: selectedDetailItem != nil ? EmotionDetailView(historyItem: selectedDetailItem!).environmentObject(viewModel) : nil,
                            isActive: Binding(
                                get: { selectedDetailItem?.id == historyItem.id },
                                set: { _ in selectedDetailItem = nil }
                            )
                        ) {
                            EmptyView()
                        }
                        .opacity(0)
                    )
                    .transition(.asymmetric(
                        insertion: .move(edge: .bottom).combined(with: .opacity),
                        removal: .move(edge: .top).combined(with: .opacity)
                    ))
                }
            }
            .padding(.horizontal, 24)
            .padding(.top, 24)
        }
        //.background(Color(red: 0.95, green: 0.95, blue: 0.95))
    }
    
    // ÂØºËà™Âà∞ËØ¶ÊÉÖÈ°µ
    private func navigateToDetail(_ historyItem: EmotionHistoryItem) {
        selectedDetailItem = historyItem
    }
    
    // ÂØºËà™Âà∞Êî∂‰ª∂ÁÆ±
    private func navigateToInbox(emotionEntryId: String? = nil) {
        // ÂèëÈÄÅÈÄöÁü•ËÆ©MainTabViewÂàáÊç¢Âà∞Êî∂‰ª∂ÁÆ±Ê†áÁ≠æ
        var userInfo: [String: Any] = [:]
        if let emotionEntryId = emotionEntryId {
            userInfo["emotionEntryId"] = emotionEntryId
        }
        
        NotificationCenter.default.post(name: .openInbox, object: nil, userInfo: userInfo)
        
        // ÊòæÁ§∫Á°ÆËÆ§ÊèêÁ§∫
        toastMessage = "Navigated to Inbox"
        toastIcon = "envelope"
        showingSuccessToast = true
    }
    
    // ÊòæÁ§∫ÊàêÂäüÊèêÁ§∫
    private func showSuccessToast(for status: ActionStatus) {
        switch status {
        case .discarded:
            toastMessage = "Successfully discarded"
            toastIcon = "trash"
        case .sent:
            toastMessage = "Successfully sent"
            toastIcon = "paperplane"
        case .sealed:
            toastMessage = "Successfully sealed"
            toastIcon = "archivebox.fill"
        default:
            return
        }
        
        showingSuccessToast = true
    }
    
    // ÂèñÊ∂àÈÄâÊã©Êìç‰Ωú
    private func cancelSelecting() {
        // Â∞ÜÊâÄÊúâÂ§Ñ‰∫éselectingÂíåÁ°ÆËÆ§Áä∂ÊÄÅÁöÑÂç°ÁâáËøîÂõûÈÄÇÂΩìÁöÑÁä∂ÊÄÅ
        for item in viewModel.filteredHistoryItems {
            if item.actionStatus == .selecting || 
               item.actionStatus == .discardingConfirm ||
               item.actionStatus == .sendingConfirm ||
               item.actionStatus == .sealingConfirm {
                withAnimation(.spring(response: 0.5, dampingFraction: 0.8)) {
                    // Ê†πÊçÆÊÉÖÁª™ËÆ∞ÂΩïÁöÑÂØÑÂá∫Áä∂ÊÄÅÂÜ≥ÂÆöÊÅ¢Â§çÂà∞‰ªÄ‰πàÁä∂ÊÄÅ
                    let wasAlreadySent = item.emotionEntry.sentDate != nil || item.emotionEntry.hasAIReply
                    let targetStatus: ActionStatus = wasAlreadySent ? .sent : .normal
                    // Áä∂ÊÄÅÊÅ¢Â§çÊó∂‰∏çËß¶ÂèëAIÂõû‰ø°ÁîüÊàêÔºåÈÅøÂÖçÈáçÂ§çÂØÑÂá∫
                    viewModel.updateActionStatus(for: item.id, to: targetStatus, shouldTriggerAIReply: false)
                }
            }
        }
    }
    
    // Â§ÑÁêÜÊúÄÁªàÊìç‰Ωú
    private func handleFinalAction(for historyItem: EmotionHistoryItem) {
        switch historyItem.actionStatus {
        case .discarded:
            // ‰∏¢ÂºÉÔºöÊòæÁ§∫ÊàêÂäüÊèêÁ§∫ÔºàÂ∑≤ÁªèÊòØÊúÄÁªàÁä∂ÊÄÅÔºâ
            showSuccessToast(for: .discarded)
        case .discardingConfirm:
            // ‰∏¢ÂºÉÁ°ÆËÆ§Ôºö‰ªéÂàóË°®Âà†Èô§
            viewModel.deleteHistoryItem(with: historyItem.id)
        case .sent:
            // ÂØÑÂá∫ÔºöÊòæÁ§∫ÊàêÂäüÊèêÁ§∫ÔºàÂ∑≤ÁªèÊòØÊúÄÁªàÁä∂ÊÄÅÔºâ
            showSuccessToast(for: .sent)
        case .sendingConfirm:
            // ÂØÑÂá∫Á°ÆËÆ§ÔºöÂèòÊàêÂ∑≤ÂØÑÂá∫Áä∂ÊÄÅÂπ∂Êõ¥Êñ∞ÂØÑÂá∫Êó∂Èó¥ÔºàAIÂõû‰ø°ÁîüÊàê‰ºöÂú®Áä∂ÊÄÅÊõ¥Êñ∞Êó∂Ëá™Âä®Ëß¶ÂèëÔºâ
            viewModel.updateActionStatus(for: historyItem.id, to: .sent)
            
            // ÂêåÊó∂Êõ¥Êñ∞emotionEntryÁöÑsentDateÂ≠óÊÆµÔºåÁ°Æ‰øùÊï∞ÊçÆ‰∏ÄËá¥ÊÄß
            let updatedEntry = EmotionEntry(
                id: historyItem.emotionEntry.id,
                date: historyItem.emotionEntry.date,
                place: historyItem.emotionEntry.place,
                people: historyItem.emotionEntry.people,
                whatHappened: historyItem.emotionEntry.whatHappened,
                think: historyItem.emotionEntry.think,
                feel: historyItem.emotionEntry.feel,
                reaction: historyItem.emotionEntry.reaction,
                need: historyItem.emotionEntry.need,
                recordSeverity: historyItem.emotionEntry.recordSeverity,
                why: historyItem.emotionEntry.why,
                ifElse: historyItem.emotionEntry.ifElse,
                nextTime: historyItem.emotionEntry.nextTime,
                processSeverity: historyItem.emotionEntry.processSeverity,
                sentDate: Date(), // ËÆæÁΩÆÂØÑÂá∫Êó∂Èó¥‰∏∫ÂΩìÂâçÊó∂Èó¥
                replyTone: historyItem.emotionEntry.replyTone,
                hasAIReply: historyItem.emotionEntry.hasAIReply
            )
            viewModel.updateHistoryItem(itemId: historyItem.id, newEntry: updatedEntry)
            
            showSuccessToast(for: .sent)
        case .sealed:
            // Â∞ÅÂ≠òÔºöÊòæÁ§∫ÊàêÂäüÊèêÁ§∫ÔºàÂ∑≤ÁªèÊòØÊúÄÁªàÁä∂ÊÄÅÔºâ
            showSuccessToast(for: .sealed)
        case .sealingConfirm:
            // Â∞ÅÂ≠òÁ°ÆËÆ§ÔºöÂèòÊàêÈîÅÂÆöÁä∂ÊÄÅÂπ∂ÁßªÂà∞ÂàóË°®ÊúÄÂêé
            viewModel.updateActionStatus(for: historyItem.id, to: .locked)
            viewModel.moveToLast(itemId: historyItem.id)
            showSuccessToast(for: .sealed)
        default:
            break
        }
    }
}

